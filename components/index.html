<!DOCTYPE html>
<html lang="en">
    <head>
        <meta content="IE=edge" http-equiv="X-UA-Compatible">
        <meta charset="utf-8">
        <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Building Robots with Rock and Syskit</title>

        <link href="../images/favicon.ico" rel="icon" type="image/ico" relative="true" />
        <link href="../stylesheets/site.css" rel="stylesheet" />
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    </head>

    <body class="components components_index">
            <!-- top navbar -->
    <nav class="navbar navbar-inverse">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">
                    <li><a href="../">Home</a></li>
                    <li><a href="../about.html">About</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3" role="complementary">
                <nav class="docs-sidebar" data-spy="affix">
                    <ul class="nav"><li class='child'><a href="../">Building robots with Rock and Syskit</a></li><li class='parent'><span class='parent-label'><a href="../basics/">Basics</a></span><ul><li class='child'><a href="../basics/">Introduction</a></li><li class='child'><a href="../basics/installation.html">Installation</a></li><li class='child'><a href="../basics/day_to_day.html">Day-to-day Workspace Commands</a></li><li class='child'><a href="../basics/getting_started.html">Getting Started</a></li><li class='child'><a href="../basics/composition.html">Compositions</a></li><li class='child'><a href="../basics/constant_generator.html">Constant Generator</a></li><li class='child'><a href="../basics/devices.html">Profiles and Devices</a></li><li class='child'><a href="../basics/deployment.html">Deployment</a></li><li class='child'><a href="../basics/publishing.html">Publishing</a></li><li class='child'><a href="../basics/validation.html">Configuration Consistency</a></li><li class='child'><a href="../basics/recap.html">Recap</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../runtime_overview/">Runtime Overview</a></span><ul><li class='child'><a href="../runtime_overview/">Introduction</a></li><li class='child'><a href="../runtime_overview/task_structure.html">Task Structures</a></li><li class='child'><a href="../runtime_overview/event_loop.html">Event Loop</a></li><li class='child'><a href="../runtime_overview/exceptions.html">Errors</a></li><li class='child'><a href="../runtime_overview/live_data.html">Live Data Visualization</a></li><li class='child'><a href="../runtime_overview/recap.html">Recap</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../workspace/">Workspace and Packages</a></span><ul><li class='child'><a href="../workspace/">Introduction</a></li><li class='child'><a href="../workspace/conventions.html">Conventions</a></li><li class='child'><a href="../workspace/setup.html">Starting a New Project</a></li><li class='child'><a href="../workspace/add_packages.html">Adding new packages</a></li><li class='child'><a href="../workspace/os_dependencies.html">OS Dependencies</a></li><li class='child'><a href="../workspace/managing.html">Build configuration design</a></li><li class='child'><a href="../workspace/troubleshooting.html">Troubleshooting</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../libraries/">Libraries</a></span><ul><li class='child'><a href="../libraries/">Introduction</a></li><li class='child'><a href="../libraries/add_packages.html">Add packages</a></li><li class='child'><a href="../libraries/cpp_libraries.html">C++ Library Packages</a></li><li class='child'><a href="../libraries/ruby_libraries.html">Ruby Library Packages</a></li><li class='child'><a href="../libraries/vscode.html">The VSCode workflow</a></li></ul></li><li class='parent active'><span class='parent-label'><a href="./">Components</a></span><ul><li class='child active'><a href="./">Introduction</a></li><li class='child'><a href="defining_types.html">Defining Types</a></li><li class='child'><a href="importing_types.html">Importing Types</a></li><li class='child'><a href="interface.html">Interface</a></li><li class='child'><a href="state_machine.html">State Machine</a></li><li class='child'><a href="writing_the_hooks.html">Writing the Hooks</a></li><li class='child'><a href="timestamping.html">Timestamping</a></li><li class='child'><a href="deployment.html">Deployments</a></li><li class='child'><a href="runtime.html">Runtime</a></li><li class='child'><a href="types_in_ruby.html">Types in Ruby</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../component_networks/">Designing Component Networks</a></span><ul><li class='child'><a href="../component_networks/">Introduction</a></li><li class='child'><a href="../component_networks/composition.html">Compositions</a></li><li class='child'><a href="../component_networks/profiles.html">Profiles</a></li><li class='child'><a href="../component_networks/reusable_networks.html">Reusable Networks</a></li><li class='child'><a href="../component_networks/transformations.html">Transformations</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../testing/">Testing and Debugging</a></span><ul><li class='child'><a href="../testing/">Introduction</a></li><li class='child'><a href="../testing/integration.html">Integration Tests</a></li></ul></li></ul>
                </nav>
            </div>
            <div class="col-md-9" role="main">
                <h1 class="no_toc" id="components">Components</h1>

<ul id="markdown-toc">
  <li><a href="#componentlibrary-separation" id="markdown-toc-componentlibrary-separation">Component/Library Separation</a></li>
  <li><a href="#introduction-to-components" id="markdown-toc-introduction-to-components">Introduction to Components</a></li>
  <li><a href="#type-system" id="markdown-toc-type-system">Type System</a></li>
  <li><a href="#creating-and-adding-packages-to-the-workspace" id="markdown-toc-creating-and-adding-packages-to-the-workspace">Creating and Adding Packages to the Workspace</a></li>
  <li><a href="#development-workflow" id="markdown-toc-development-workflow">Development Workflow</a></li>
  <li><a href="#cxx_standard" id="markdown-toc-cxx_standard">C++ Standard</a></li>
  <li><a href="#runtime-workflow" id="markdown-toc-runtime-workflow">Runtime Workflow</a></li>
</ul>

<h2 id="componentlibrary-separation">Component/Library Separation</h2>

<p>We <strong>strongly recommend</strong> that you develop most of your system's functionality
in <strong>libraries</strong>, instead of doing within the component framework itself. For C++, this
means creating C++ library packages that are then later integrated into Rock
components to expose that functionality to the system. For Ruby, this means
creating Ruby packages that are then used within the Ruby layers (e.g. Syskit)</p>

<p><strong>Why ?</strong> Developing libraries is a matter of "general" software engineering
best practices. Robotics is a small field, software engineering is not. By
doing most of your work in a framework-independent manner, you ensure that you
can benefit from the much bigger ecosystem. Moreover, we haven't seen the end
of the robotic frameworks. By developing libraries that are
framework-independent, you ensure that you can integrate them elsewhere if needs
be, cutting the time and effort by <strong>a lot</strong>.</p>

<p class="note"><strong>How does Rock help the library/framework separation ?</strong> Supporting this
separation during the development process is a main design driver for the
tooling. For instance, Rock's build system - <code>autoproj</code> - is not assumed to be
present by the rest of the packages. Second, <code>orogen</code> exposes C++ structures
directly into the type system. The widespread approach - using IDLs - usually
end up pushing the developers to integrate code-generated structures in their
libraries thus tying them to the framework itself.</p>

<p>Developing libraries is covered in the <a href="../libraries">libraries</a> section.
This section deals with using library-integrated functionality and using them
to build data-processing components.</p>

<h2 id="introduction-to-components">Introduction to Components</h2>

<p>Within Rock, components are <em>implemented</em> in C++. They are also <em>specified</em> in a
Ruby domain-specific language that is processed by a code generation tool,
<strong>oroGen</strong>. This tool ensures that the component's interface matches its
specification. It also removes most of the crude boilerplate-writing code that
is the declaration in C++ of the component interfaces.</p>

<p>From a package point of view, components are defined in an orogen package. The
orogen packages are all placed in the <code>/orogen/</code> subdirectory of one of the
<a href="../workspace/conventions.html">package categories</a></p>

<p class="note"><strong>Important</strong> an oroGen package and a library can share the same basename (e.g.
<code>drivers/hokuyo</code> and <code>drivers/orogen/hokuyo</code>). This is even a recommended
behavior when an orogen package is mainly tied to a certain library.</p>

<p>From this page on, the rest of this section will deal with the integration of
the functionality from C++ libraries into Rock components by means of orogen.
But let's first talk about how to create an orogen package.</p>

<h2 id="type-system">Type System</h2>

<p>One of the first thing that a system designer has to think about is defining
the data structures that will be used to exchange data between the system's
parts (in our case, between components, and between the components and Syskit).</p>

<p>These types are used for a few different things</p>

<ul>
  <li>in the communication between components, and between components and Syskit
(ports)</li>
  <li>in the configuration of the component (properties)</li>
  <li>to assess the component's state, i.e. diagnotics and monitoring (ports)</li>
  <li>to provide information about the component's internal state, i.e. debugging (ports)</li>
</ul>

<p>In Rock, the types are defined in C++, ideally within the libraries but
sometimes within the component packages. They are then exported into Rock's
type system to allow for their <strong>transport</strong> (communication between
processes), but also for their manipulation in Syskit.</p>

<p>This section will detail <a href="defining_types.html">how types are defined</a>, how
they can <a href="importing_types.html">be used within oroGen packages</a>, and how
they are <a href="types_in_ruby.html">mapped into the Ruby layers</a> to ease their use
on the tooling side.</p>

<h2 id="creating-and-adding-packages-to-the-workspace">Creating and Adding Packages to the Workspace</h2>

<p>This is covered in the <a href="../workspace/add_packages.html">Workspace and Packages section</a></p>

<p>The workflow of the component scaffolding tool <code>rock-create-orogen</code> is a bit
different, though, so let's go through its workflow. Let's assume we want to
create a <code>planning/orogen/sbpl</code> package, the workflow would be to:</p>

<div class="highlight"><pre class="highlight plaintext"><code>acd
cd planning/orogen/
rock-create-orogen sbpl
cd sbpl
# Edit sbpl.orogen
rock-create-orogen
# Fix potential mistakes and re-run rock-create-orogen until there are no errors
# …
</code></pre></div>
<p class="note"><strong>What does <code>rock-create-orogen</code> do ?</strong> <code>orogen</code> does "private" code generation
in a <code>.orogen</code> subfolder of the package, and creates a <code>templates/</code> folder.
<code>rock-create-orogen</code> ensures that the initial repository commit does not
contain any of these. If you don't want to use <code>git</code>, or if you're confident
that you know which files and folder to commit and which to leave out, the second
run is not neeeded.</p>

<p>Once this is done, <a href="../workspace/add_packages.html#orogen">add the package to your build configuration</a></p>

<h2 id="development-workflow">Development Workflow</h2>

<p>Developing a component involves doing mainly three things:</p>

<ul>
  <li><a href="importing_types.html">defining and importing data types</a> for usage on
its interface. The recommended course of action for functionality developed
targetting Rock is to make sure that the library package defines C++ types
<a href="defining_types.html">compatible with Rock's type system</a>, and
import these types directly. Alternatively, you may define types within the
oroGen package and do the conversion between the library and the Rock
type system, either manually or automatically using <a href="importing_types.html#opaques">opaque types</a></li>
  <li>defining the component(s) interface(s) in the orogen file</li>
  <li>implementing the processing parts of the component in C++</li>
</ul>

<p class="important"><strong>Let's remember</strong> we strongly recommend that you develop the bulk of your
component's functionality in <strong>libraries</strong>, instead of doing in the components
themselves.</p>

<p>Each time data types or the orogen specification are modified, one must run
orogen to re-generate code. After code generation, the package behaves like
a CMake package.</p>

<p>The best way to build an oroGen package is to use
<a href="../basics/day_to_day.html"><code>amake</code></a>. It takes care of code generation and
building the generated CMake package.</p>

<h2 id="cxx_standard">C++ Standard</h2>

<p>The C++ standard used to interpret the data type files and to build the component's C++
code is the latest standard that its dependencies require. There is currently no
way to explicitely tell orogen to use a different standard. For instance, if
your oroGen project uses a library that sets C++11 using <a href="../libraries/cpp_libraries.html#cxx_standard">the Rock CMake
macros</a>, the oroGen project will use C++11
too.</p>

<h2 id="runtime-workflow">Runtime Workflow</h2>

<p>"Developing" a component in C++ within Rock is to write a C++ class that
interacts with its inputs/outputs. This class does not specify when the
processing is going to be called, and under which OS resource (threads,
processes). It is said that the <em>component implementation</em> is separated
from the <em>system deployment</em>. The first one is really writing the C++ code that
interacts with the component's interface. The second one is part of system
integration.</p>

<p>What it means in practice is that a component implement is nothing more than a standalone
C++ class. This C++ class can be instantiated multiple times in a single
system, using different periods or triggering mechanisms, different threading
policies, …</p>

<p>When you define components in oroGen, you create a <em>task library</em>, which is a
shared library in which the task context classes are defined. Then, you need to
put these libraries in <em>deployments</em> (which is also done by oroGen). Finally,
you can start these deployments, connect the tasks together, and monitor them
using Syskit.</p>

<p><img src="media/deployment_process.svg" alt="Runtime Workflow Diagram" class="fullwidth" /></p>

<p><strong>Next</strong> Let's get an overview of <a href="defining_types.html">type definitions</a></p>

            </div>
        </div>
    </div>

    <script>
    $('.docs-sidebar').affix({
        offset: {
            top: $('.docs-sidebar').offset().top
        }
    });
    </script>


        <footer class="container-fluid text-center">
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Building Robots with Rock and Syskit</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/doudou" property="cc:attributionName" rel="cc:attributionURL">Sylvain Joyeux</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. Copyright Sylvain Joyeux and Contributors
        </footer>
    </body>
</html>
