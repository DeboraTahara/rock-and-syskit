<!DOCTYPE html>
<html lang="en">
    <head>
        <meta content="IE=edge" http-equiv="X-UA-Compatible">
        <meta charset="utf-8">
        <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Robot Construction Toolkit</title>

        <link href="../images/favicon.ico" rel="icon" type="image/ico" relative="true" />
        <link href="../stylesheets/site.css" rel="stylesheet" />
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" />
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
        <style>
          /* Remove the navbar's default margin-bottom and rounded borders */
          .navbar {
              margin-bottom: 0;
              border-radius: 0;

          }

          /* Set height of the grid so .sidenav can be 100% (adjust as needed) */
          .row.content {height: 450px}

          /* Set gray background color and 100% height */
          .sidenav {
              padding-top: 20px;
              background-color: #f1f1f1;
              height: 100%;
          }

          /* Set black background color, white text and some padding */
          footer {
              background-color: #000000;
              color: white;
              padding: 5px;
          }

          /* On small screens, set height to 'auto' for sidenav and grid */
          @media screen and (max-width: 767px) {
              .sidenav {
                  height: auto;
                  padding: 15px;
              }
              .row.content {height:auto;}
          }
        </style>
    </head>

    <body class="syskit_basics syskit_basics_brief_introduction">

            <!-- top navbar -->
    <nav class="navbar navbar-inverse">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">
                    <li><a href="../">Home</a></li>
                    <li class="active"><a href="../documentation/">Documentation</a></li>
                    <li><a href="../tutorials/">Tutorials</a></li>
                    <li><a href="../about.html">About</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <div class="container-fluid text-center">
        <div class="row content">
            <div class="col-sm-2 sidenav">
                <p><a href="transformations.html">Transformations</a></p>
            </div>
            <div class="col-sm-8 text-left">
                <h1 id="a-brief-introduction">A Brief Introduction</h1>

<h2 id="basic-concepts">Basic Concepts</h2>

<p><strong>Design and runtime</strong> Rock is a model-based architecture. A Rock system is
described <strong>at design time</strong>, that is before any piece of the actual
processing code needs to be run, and can verify properties regarding the
final system then. <strong>Runtime</strong> then refers to the point where the actual data
processing code runs – which involves hardware or simulation in case of
robotics.</p>

<p><strong>Libraries, Components and System</strong> Deep-down, the bulk of the code that
makes a Rock system is organized in libraries. Libraries propose APIs -
interfaces - to solve particular problems, e.g. OpenCV to process images, PCL
to process point clouds, a GPS driver to control a GPS device and read GPS
positions, … This way to organize software development is nothing specific to
Rock or even robotics. It's the principal way software is developed <em>period</em>.</p>

<p>However, libraries <em>offer</em> functionality, but do not specify how this
functionality should be integrated to offer a "runtime", i.e. how the actual
data being processed can be passed to the processing code in the libraries,
from the sensors to the actuators, to turn all that code into a robot.</p>

<p>The paradigm that Rock follows is the one of <strong>components</strong>. Components are
black boxes that have inputs and produce outputs. It's by meshing these
components together - connecting outputs to inputs - that an active
sensor-processing-actuator loop is created and that the robot can act and react
in its environment. In addition to this <em>dataflow interface</em> (data inputs and
outputs), Rock components also offer a <em>configuration</em> interface where parameters
can be chosen and tested.</p>

<p>What sets Rock apart from other component-based systems is the ability to
reconfigure the component network to fit the situation as best as possible.
This is made possible by explicitly choosing at any point in time both which
components are active, and which output-input connections are present in the
network. <strong>Syskit</strong> is the tool that makes such a design feasible, pushing most
of the complexity of such a dynamic system into the tool, leaving the developer
make higher-level design decisions.</p>

<p><strong>Software Packages</strong> A software package is a way to distribute code (software).
Rock's only convention is to have a one library = one package correspondence or
one component = one package. Libraries should be "fat", components "slim" (i.e.
most of the functionality should be implemented as a component-independent
library.</p>

<p>That's all for now … let's get to describe a <a href="sdf.html">system within Gazebo using SDF</a></p>

            </div>
        </div>
    </div>


        <footer class="container-fluid text-center">
            <p>Rock in your own way!</p>
        </footer>
    </body>
</html>
