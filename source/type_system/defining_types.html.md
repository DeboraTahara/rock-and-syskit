---
layout: documentation
title: Defining Types
sort_info: 10
---

# Defining Types
{:.no_toc}

- TOC
{:toc}


Types are described using C++. However, not all C++ types can be used in the data
flow. There are limitations to which types are acceptable, and ways to work
around these limtations.

They are then injected in Rock's type system through Rock's code generation
tool, `orogen`. We will see [later](../integrating_functionality/components.html) that this tool is
also the tool that is used to create components.

## Creating an orogen package for type definition

Packages are created with the `rock-create-orogen` tool. Let's assume we want
to create a `planning/orogen/sbpl` package, the workflow would be to:

~~~
acd
cd planning/orogen/
rock-create-orogen sbpl
cd sbpl
# Edit sbpl.orogen
rock-create-orogen
# Fix potential mistakes and re-run rock-create-orogen until there are no errors
# â€¦
~~~

If we are going to use this package only for type definitions, you will have to
delete all the `task_context` definitions. The orogen file will end up looking
like this:

~~~ ruby
name "name_of_package"
version "0.1"

# Import types from other orgen projects as well as
# C++ headers within the orogen package itself
import_types_from "..."
import_types_from "..."
import_types_from "..."
import_types_from "..."

# Import types from libraries
using_library "other_lib"
import_types_from "other_lib/Header.hpp"

# Choose which types are going to be usable on
# component interfaces
typekit.export_types "/name/of/type",
  "/name/of/another/type"
~~~

**What does `rock-create-orogen` do ?** `orogen` does "private" code generation
in a `.orogen` subfolder of the package, and creates a `templates/` folder.
`rock-create-orogen` ensures that the initial repository commit does not
contain any of these. If you don't want to use `git`, or if you're confident
that you know which files and folder to commit and which to leave out, the second
run is not neeeded.
{: .note}

Once this is done, [add the package to your build
configuration](../workspace/add_packages.html#orogen)

## Type Declarations {#type_declarations}

Not all C++ types can be used by Rock's type system. To be usable as-is, a type must:

* be default constructible and copyable (i.e. have a constructor that have no
  arguments and can be copied).
* have no private fields
* have only public ancestors, that fit the definition of "acceptable type".
* not use pointers.

In addition, Rock does support `std::string` and `std::vector` standard
classes, so you can use them freely. Moreover, for types that can't be directly
managed by oroGen, the mechanism of [opaque types](#opaques) allows to
integrate them in the Rock workflow anyways.

Example: defining a Time class

~~~ cpp
namespace base {
  struct Time
  {
    uint64_t microseconds;
    static Time fromMilliseconds(uint64_t ms);
    Time operator +(Time const& other);
  };
}
~~~

## Type Names {#naming_scheme}

The Rock type system does not use the same naming scheme than C++ for types.
Parts of a type are separated by a forward slash `/`. A well-formed type name
is always absolute (always starts with /).

For instance, Rock's `base::Time` is `/base/Time` within the type system.

Containers derived from `/std/vector` do use the `<>` markers: `/std/vector</base/Time>`

## Importing Types {#import}

In an oroGen project, one adds one or more `import_types_from` statements to
include headers from within the oroGen package, headers from other packages or
to import all types that have already been defined within another oroGen
package. The template generated by `rock-create-orogen` has created a header
file for this purpose:

~~~ ruby
import_types_from "myprojectTypes.hpp"
~~~

Such headers must be self-contained, that is include all the headers they,
themselves, require.  Moreover, only the types that are _directly_ defined in
the imported header (and the types they themselves use) will be exported in the
typekit. Finally, one can directly use types defined in a library, provided
that this library gives a pkg-config file for dependency discovery.

Let's consider a `drivers/hokuyo` package that would define a
`hokuyo::Statistics` structure. Assuming that this package (1) installs a
`hokuyo.pc` file - all Rock packages do by default - and (2) installs the
relevant header as `Statistics.hpp`, one can import the type with

~~~ ruby
using_library "hokuyo"
import_types_from "hokuyo/Statistics.hpp"
~~~

**Note** the pkg-config name of a Rock library package is the package's basename
(i.e. `hokuyo` for `drivers/hokuyo`).
{: .note}

Finally, if the types you are interested in are already imported by another
oroGen package, it is recommended to reuse the code already generated there
(if only to reduce compilation times).

To import types from another project, one does:

~~~ ruby
import_types_from "project_name"
~~~

**Note** the name of an oroGen package as used in `import_types_from` is the
package's basename (i.e. `hokuyo` for `drivers/orogen/hokuyo`). An oroGen
package and a library can share the same basename (e.g. `drivers/hokuyo` and
`drivers/orogen/hokuyo`). This is even a recommended behavior when an orogen
package is mainly tied to a certain library.
{: .note}

**Important** The `using_library "library_name"` and `import_types_from "project_name"`
implicitly create a dependency between the oroGen package you're working on and
other packages.  These dependencies **must** be made explicit by adding them to
the oroGen package's [`manifest.xml`](../workspace/add_packages.html#manifest_xml).
{: .important}

The following two sections on [C++ templates](#templates) and [opaque
types](#opaques) can be passed on a first reading. You can skip it to go
straight to [how types will be seen from Ruby](types_in_ruby.html).
{: .next-page}

## Handling of C++ templates {#templates}

Templates are not directly understood by oroGen. However, explicit
instantiations of them can be used.

Unfortunately, typedef'ing the type that you need is not enough. You have to
use the instantiated template directly in a structure. To work around this, you
can define a structure whose name contains the `orogen_workaround` string to
get the template instantiated, and then define the typedefs that you will
actually use in your typekits and oroGen task interfaces.

For instance, with

~~~ cpp
template <typename Scalar, int DIM>
struct Vector {
  Scalar values[DIM];
};

struct __orogen_workaround {
  Vector<3> vector3;
  Vector<4> vector4;
};
~~~

One can use Vector&lt;3&gt; in its orogen interface, and in other structures.
The `__orogen_workaround` structure itself will be ignored by oroGen to avoid
polluting the type system.


## Opaque Types {#opaques}

Opaque types are a way to enable oroGen to handle types that it cannot handle
completely automatically. The general idea is that you provide oroGen with a
"marshalling structure" that (1) [it can understand](#type_declarations) and
(2) can hold all the data that the "real type" holds. Then, you have to
implement two conversion functions: one that converts from the marshalling type,
and one to the marshalling type.

So, it involves doing one copy. What is the gain ?

Opaque types provide you with the advantage that other types that use opaque
types (i.e.  structures with fields that are from opaque types, std::vector,
arrays) will be automatically handled by oroGen. I.e. you write the conversion
function for the types that oroGen can't handle and let it do the rest of the
work.

Moreover, oroGen will be able to generate typekits for all the transports it
can handle.

Finally, the conversion to and from the marshalling type is only done in
inter-process transports. When communicating across threads, the data structure
is copied as-is.

To use opaque types, you first have to create a wrapper type (a.k.a.
"intermediate type") for the opaque. In the case of `Eigen::Vector3d`, a
suitable wrapper would be

~~~ cpp
namespace wrappers
{
    struct Vector3d
    {
        double x, y, z;
    };
}
~~~

The wrapper is usually defined within the oroGen package itself, in a
`wrappers/` subdirectory placed at the root of the package. It then needs to be
[imported with `import_types_from`](#import).  Finally, one can use
`opaque_type` to declare the opaque.

~~~ ruby
import_types_from "wrappers/Vector3d.hpp"
opaque_type "/Eigen/Vector3d", "/wrappers/Vector3d"
~~~

where `wrappers::Vector3d` is the marshalling structure defined in
`wrappers/Vector3d.hpp`. Moreover, if getting the definition of the opaque type
requires new include directories that are not yet added to the typekit through
the [using_library mechanism](#import), you will have to detect them in the
Ruby code and add them with the `include:` option

~~~ ruby
import_types_from "wrappers/Vector3d.hpp"
opaque_type "/Eigen/Vector3d", "/wrappers/Vector3d", include: eigen_prefix
~~~

Once you have re-generated the project, a typekit/ directory is created with
two files, `Opaques.cpp` and `Opaques.hpp` in it. These files hold the
`toIntermediate` and `fromIntermediate` conversion functions that should be
used by oroGen to convert the opaque to the wrapper and the wrapper to the
opaque. Note that any function will do: you may change the plain functions to
e.g. templates if you need to defined opaques for many types (as
`base/orogen/types` does [for the Eigen
types](https://github.com/rock-core/base-orogen-types/blob/master/typekit/Opaques.hpp)).

**Updates to Opaques.hpp/Opaques.cpp** If you add new opaques to an orogen
project that already has some, you will need to copy the corresponding
toIntermediate/fromIntermediate conversion functions manually from
templates/typekit/Opaques.cpp. Note that this is a general behavior: oroGen
will always refuse to modify a file that already exists, but update a "fresh"
template within `templates/`.
{: .important}

As explained, once you have defined an opaque type, oroGen will take care of
other types that _use_ this opaque. For instance

~~~ cpp
struct Position
{
    base::Time time;
    Eigen::Vector3d position;
};
~~~

can be used in your task interfaces without any modifications. This works for
structures, std::vector and static-size arrays. Before you may do this, however,
you need to `import_types_from` the orogen package that declared the opaque
in the first place.

**Next** Now that you know all about defining data types, let's get to understand how
they are seen [from within Ruby](types_in_ruby.html)
{: .next-page}

